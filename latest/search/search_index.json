{
    "docs": [
        {
            "location": "/", 
            "text": "LyapunovExponents.jl documentation\n\n\n\n\nInterface\n\n\nHigh-level API\n\n\nLow-level API\n\n\nAPI for CLV solver\n\n\n\n\n\n\nExample dynamical systems\n\n\nDiscrete systems\n\n\nContinuous systems\n\n\n\n\n\n\nGallery", 
            "title": "Home"
        }, 
        {
            "location": "/#lyapunovexponentsjl-documentation", 
            "text": "Interface  High-level API  Low-level API  API for CLV solver    Example dynamical systems  Discrete systems  Continuous systems    Gallery", 
            "title": "LyapunovExponents.jl documentation"
        }, 
        {
            "location": "/api/", 
            "text": "Interface\n\n\n\n\nHigh-level API\n\n\n#\n\n\nLyapunovExponents.ContinuousLEProblem\n \n \nType\n.\n\n\nContinuousLEProblem(phase_dynamics, u0 [, p];\n                    t_attr=\nnumber\n, \nkeyword arguments\n)\n\n\n\n\nThis is a short-hand notation for:\n\n\nLEProblem(ODEProblem(phase_dynamics, u0 [, p]), t_attr)\n\n\n\n\nFor the list of usable keyword arguments, see \nLEProblem\n.\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.DiscreteLEProblem\n \n \nType\n.\n\n\nDiscreteLEProblem(phase_dynamics, u0 [, p];\n                  t_attr=\nnumber\n, \nkeyword arguments\n)\n\n\n\n\nThis is a short-hand notation for:\n\n\nLEProblem(DiscreteProblem(phase_dynamics, u0 [, p]), t_attr)\n\n\n\n\nFor the list of usable keyword arguments, see \nLEProblem\n.\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.lyapunov_exponents\n \n \nFunction\n.\n\n\nlyapunov_exponents(solver)\n\n\n\n\nGet the result of Lyapunov exponents calculation stored in \nsolver\n.\n\n\nsource\n\n\nlyapunov_exponents(phase_dynamics!, u0, tspan; \nkeyword arguments\n)\n\n\n\n\nCalculate Lyapunov exponents of a dynamical system.\n\n\nsource\n\n\n\n\nLow-level API\n\n\n#\n\n\nLyapunovExponents.LEProblem\n \n \nType\n.\n\n\nLEProblem(phase_prob, t_attr; \nkeyword arguments\n)\n\n\n\n\nArguments\n\n\n\n\nphase_prob\n: Phase space dynamics represented in the form of \nODEProblem\n or \nDiscreteProblem\n from DifferentialEquations.jl. \nphase_prob.tspan\n is ignored.\n\n\nt_attr::Real\n: Simulated time on the (presumed) attractor used for the solver.  It is used for computation of Lyapunov Exponents.  Roughly \nt_attr / t_renorm\n instantaneous exponents are sampled.\n\n\nt_tran::Real\n: Number of iterations to throw away to get rid of the effect from the transient dynamics.\n\n\nt_renorm::Real\n: Interval between orthonormalizations (renormalizations).\n\n\ndim_lyap::Integer\n: Number of Lyapunov exponents to be calculated. Default to the full system dimension.\n\n\nQ0::Array\n: The initial guess of the Gram-Schmidt \"Lyapunov vectors\".\n\n\ntangent_dynamics::Function\n: A vector field for solving phase space  evolution \nand\n tangent space evolution together.  If this is not  provided, \ntangent_dynamics\n is derived from \nphase_prob.f\n.  See  also \nPhaseTangentDynamics\n.\n\n\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.LESolver\n \n \nType\n.\n\n\nLESolver(prob::LEProblem; record::Bool = false)\n\n\n\n\nCreate a solver object for a \nLEProblem\n.  Record all finite-time (instantaneous) Lyapunov exponents when \nrecord = true\n is passed.\n\n\nsource\n\n\n#\n\n\nDiffEqBase.init\n \n \nFunction\n.\n\n\ninit(prob::LEProblem; \nkeyword arguments\n) :: LESolver\ninit(prob::CLVProblem; \nkeyword arguments\n) :: CLVSolver\n\n\n\n\nThese are simply the aliases of \nLESolver(prob; \nkeyword arguments\n)\n and \nCLVSolver(prob; \nkeyword arguments\n)\n.  See \nLESolver\n and \nCLVSolver\n for supported keyword arguments.\n\n\nsource\n\n\n#\n\n\nDiffEqBase.step!\n \n \nFunction\n.\n\n\nstep!(integ::DEIntegrator [, dt [, stop_at_tdt]])\n\n\n\n\nPerform one (successful) step on the integrator.\n\n\nAlternative, if a \ndt\n is given, then \nstep!\n the integrator until there is a temporal difference \n\u2265 dt\n in \ninteg.t\n.  When \ntrue\n is passed to the optional third argument, the integrator advances exactly \ndt\n.\n\n\nsource\n\n\nstep!(stage::AbstractRenormalizer)\n\n\n\n\nEvolve the dynamics and then do an orthonormalization.\n\n\nsource\n\n\n#\n\n\nDiffEqBase.solve!\n \n \nFunction\n.\n\n\nsolve!(solver::LESolver; \nkeyword arguments\n) :: LESolver\nsolve!(solver::CLVSolver; \nkeyword arguments\n) :: CLVSolver\n\n\n\n\nSolve pre-initialized problem.\n\n\nsource\n\n\n#\n\n\nDiffEqBase.solve\n \n \nFunction\n.\n\n\nsolve(prob::LEProblem; \nkeyword arguments\n) :: LESolution\nsolve(prob::CLVProblem; \nkeyword arguments\n) :: CLVSolution\n\n\n\n\nEquivalent to:\n\n\nsolver = init(prob; \nkeyword arguments except progress\n)\nsolve!(solver; progress=progress)\nsolver.sol\n\n\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.PhaseTangentDynamics\n \n \nType\n.\n\n\nAuto-generated dynamics for solving phase and tangent dynamics together.\n\n\nsource\n\n\n\n\nAPI for CLV solver\n\n\n#\n\n\nLyapunovExponents.CovariantVectors.CLVProblem\n \n \nType\n.\n\n\nCLVProblem(phase_prob, t_clv; \nkeyword arguments\n)\nCLVProblem(le_prob::LEProblem; \nkeyword arguments\n)\n\n\n\n\nCovariant Lyapunov vector (CLV) problem.  This is a struct that holds the dynamical system definition (\nphase_prob\n and \ntangent_dynamics\n) and the configuration parameters for the algorithm (\nt_clv\n, etc.).\n\n\nThe CLVs are calculated using the 'dynamical' algorithm proposed by Ginelli et al. (2007, 2013).\n\n\nArguments\n\n\n\n\nt_clv::Real\n: Time spam for which CLV are sampled. It is \n0.8 * le_prob.t_attr\n when constructed from \nLEProblem\n.\n\n\nt_forward_tran::Real\n, \nt_backward_tran::Real\n: Forward and backward transient dynamics.  They are \n0.1 * le_prob.t_attr\n when constructed from \nLEProblem\n.\n\n\nSee \nLEProblem\n for \nphase_prob\n, \nt_renorm\n, \ntangent_dynamics\n and \nQ0\n.\n\n\n\n\nExamples (in the online documentation)\n\n\n\n\nGinelli et al. (2007), Figure 1a\n\n\nCovariant Lyapunov vectors on the Lorenz attractor\n\n\n\n\nSee: \nhttps://tkf.github.io/LyapunovExponents.jl/latest/gallery/\n\n\nReference\n\n\n\n\nGinelli, F., Poggi, P., Turchi, A., Chat\u00e9, H., Livi, R., \n Politi, A. (2007). \nCharacterizing Dynamics with Covariant Lyapunov Vectors.\n Physical Review Letters, 99(13), 1\u20134. \nhttp://doi.org/10.1103/PhysRevLett.99.130601\n\n\nGinelli, F., Chat\u00e9, H., Livi, R., \n Politi, A. (2013). \nCovariant Lyapunov vectors.\n Journal of Physics A: Mathematical and Theoretical, 46(25), 254005. \nhttp://doi.org/10.1088/1751-8113/46/25/254005\n\n\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.CovariantVectors.CLVSolver\n \n \nType\n.\n\n\nCLVSolver(prob::CLVProblem; \nkeyword arguments\n)\nCLVSolver(prob::LEProblem; \nkeyword arguments\n)\n\n\n\n\nThe preferred and equivalent method to get a solver for a \nCLVProblem\n is \ninit(prob::CLVProblem)\n.  Note that \nCLVSolver(prob::LEProblem)\n is equivalent to \ninit(CLVProblem(prob))\n.\n\n\nArguments\n\n\n\n\nrecord::Vector{Symbol}\n: Variables to be saved.  A subset of \n[:G, :C, :D, :x]\n.\n\n\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.CovariantVectors.CLV\n \n \nModule\n.\n\n\nConvenience methods for accessing CLV matrices.\n\n\nMethods \nCLV.C\n, \nCLV.R\n and \nCLV.G\n are the accessor to the matrices $C$, $R$ and $G$ in\n\n\n\n\n\nG_{n+k} C_{n+k} D_{k,n} = M_{k,n} G_n C_n = G_{n+k} R_{k,n} C_n\n\n\n\n\n\n(Eq. 32, Ginelli et al., 2013).\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.CovariantVectors.CLV.M\n \n \nFunction\n.\n\n\n$M_n$ (the cocycle)\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.CovariantVectors.CLV.G\n \n \nFunction\n.\n\n\n$G_n$ (\nQ\n from the QR decomposition of $M_{k,n-k} G_{n-k}$)\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.CovariantVectors.CLV.R\n \n \nFunction\n.\n\n\n$R_n$ (\nR\n from the QR decomposition of $M_{k,n-k} G_{n-k}$)\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.CovariantVectors.CLV.R_prev\n \n \nFunction\n.\n\n\n$R_{n-k}$\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.CovariantVectors.CLV.C\n \n \nFunction\n.\n\n\n$C_n$\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.CovariantVectors.CLV.D\n \n \nFunction\n.\n\n\n$D_n$\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.phase_state\n \n \nFunction\n.\n\n\nphase_state(stage) :: Vector\n\n\n\n\nGet current phase-space state stored in \nstage\n.\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.CovariantVectors.forward_dynamics!\n \n \nFunction\n.\n\n\nforward_dynamics!(solver::CLVSolver) :: ForwardDynamics\n\n\n\n\nSolve the CLV problem up to the forward dynamics stage and return an iterator to step through the forward dynamics. See also: \nbackward_dynamics!\n, \ngoto!\n.\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.CovariantVectors.backward_dynamics!\n \n \nFunction\n.\n\n\nbackward_dynamics!(solver::CLVSolver) :: BackwardDynamics\n\n\n\n\nSolve the CLV problem up to the (final) backward dynamics stage and return an iterator to step through the backward dynamics. See also \nforward_dynamics!\n, \ngoto!\n.\n\n\nNote that finishing iteration of the returned iterator does not finalize all the solver stages (namely, recording to \nsolver.sol\n, if non-default \nbackward_dynamics\n is used).  In this case, \nsolve!(solver)\n has to be called after the iteration.\n\n\nExample\n\n\nangles = [acos(abs(dot(C[:, 1], C[:, 2]))) * 2 / \u03c0 for C\n          in backward_dynamics!(solver)]\n\n\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.CovariantVectors.indexed_forward_dynamics!\n \n \nFunction\n.\n\n\nindexed_forward_dynamics!(solver::CLVSolver)\nindexed_forward_dynamics!(stage::ForwardDynamics)\n\n\n\n\nJust a short-hand for \nenumerate(forward_dynamics!(solver))\n. It's for symmetry with \nindexed_backward_dynamics!\n.\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.CovariantVectors.indexed_backward_dynamics!\n \n \nFunction\n.\n\n\nindexed_backward_dynamics!(solver::CLVSolver)\nindexed_backward_dynamics!(stage::BackwardDynamics)\n\n\n\n\nIt is equivalent to \nzip(some_counter, backward_dynamics!(solver))\n where \nsome_counter\n is an iterator over integers such that the same indices returned by \nindexed_forward_dynamics!\n indicate that those events are at the same time point of the backward and forward passes.  This is useful when combining matrices \nCLV.G\n and \nCLV.C\n to obtain the CLV in the (original) tangent space.\n\n\nFor such example, see: \nCovariant Lyapunov vectors on the Lorenz attractor\n in the online manual.\n\n\nNote that \nindexed_backward_dynamics!(solver::CLVSolver)\n is equivalent to\n\n\nbackward = backward_dynamics!(solver)\nindexed_backward_dynamics!(backward)\n\n\n\n\nSeparately calling \nbackward_dynamics!\n is useful when the quantities other than \nCLV.G\n (e.g., \nCLV.R\n) are required.\n\n\nSee also \nindexed_forward_dynamics!\n.\n\n\nsource\n\n\n\n\nLow-level API for CLV solver\n\n\n#\n\n\nLyapunovExponents.Stages.goto!\n \n \nFunction\n.\n\n\ngoto!(solver::StagedSolver, stage_type::Type{T}) :: T\n\n\n\n\nAdvance the \nsolver\n up to the stage of type \nstage_type\n and return it.\n\n\nsource", 
            "title": "API"
        }, 
        {
            "location": "/api/#interface", 
            "text": "", 
            "title": "Interface"
        }, 
        {
            "location": "/api/#high-level-api", 
            "text": "#  LyapunovExponents.ContinuousLEProblem     Type .  ContinuousLEProblem(phase_dynamics, u0 [, p];\n                    t_attr= number ,  keyword arguments )  This is a short-hand notation for:  LEProblem(ODEProblem(phase_dynamics, u0 [, p]), t_attr)  For the list of usable keyword arguments, see  LEProblem .  source  #  LyapunovExponents.DiscreteLEProblem     Type .  DiscreteLEProblem(phase_dynamics, u0 [, p];\n                  t_attr= number ,  keyword arguments )  This is a short-hand notation for:  LEProblem(DiscreteProblem(phase_dynamics, u0 [, p]), t_attr)  For the list of usable keyword arguments, see  LEProblem .  source  #  LyapunovExponents.lyapunov_exponents     Function .  lyapunov_exponents(solver)  Get the result of Lyapunov exponents calculation stored in  solver .  source  lyapunov_exponents(phase_dynamics!, u0, tspan;  keyword arguments )  Calculate Lyapunov exponents of a dynamical system.  source", 
            "title": "High-level API"
        }, 
        {
            "location": "/api/#low-level-api", 
            "text": "#  LyapunovExponents.LEProblem     Type .  LEProblem(phase_prob, t_attr;  keyword arguments )  Arguments   phase_prob : Phase space dynamics represented in the form of  ODEProblem  or  DiscreteProblem  from DifferentialEquations.jl.  phase_prob.tspan  is ignored.  t_attr::Real : Simulated time on the (presumed) attractor used for the solver.  It is used for computation of Lyapunov Exponents.  Roughly  t_attr / t_renorm  instantaneous exponents are sampled.  t_tran::Real : Number of iterations to throw away to get rid of the effect from the transient dynamics.  t_renorm::Real : Interval between orthonormalizations (renormalizations).  dim_lyap::Integer : Number of Lyapunov exponents to be calculated. Default to the full system dimension.  Q0::Array : The initial guess of the Gram-Schmidt \"Lyapunov vectors\".  tangent_dynamics::Function : A vector field for solving phase space  evolution  and  tangent space evolution together.  If this is not  provided,  tangent_dynamics  is derived from  phase_prob.f .  See  also  PhaseTangentDynamics .   source  #  LyapunovExponents.LESolver     Type .  LESolver(prob::LEProblem; record::Bool = false)  Create a solver object for a  LEProblem .  Record all finite-time (instantaneous) Lyapunov exponents when  record = true  is passed.  source  #  DiffEqBase.init     Function .  init(prob::LEProblem;  keyword arguments ) :: LESolver\ninit(prob::CLVProblem;  keyword arguments ) :: CLVSolver  These are simply the aliases of  LESolver(prob;  keyword arguments )  and  CLVSolver(prob;  keyword arguments ) .  See  LESolver  and  CLVSolver  for supported keyword arguments.  source  #  DiffEqBase.step!     Function .  step!(integ::DEIntegrator [, dt [, stop_at_tdt]])  Perform one (successful) step on the integrator.  Alternative, if a  dt  is given, then  step!  the integrator until there is a temporal difference  \u2265 dt  in  integ.t .  When  true  is passed to the optional third argument, the integrator advances exactly  dt .  source  step!(stage::AbstractRenormalizer)  Evolve the dynamics and then do an orthonormalization.  source  #  DiffEqBase.solve!     Function .  solve!(solver::LESolver;  keyword arguments ) :: LESolver\nsolve!(solver::CLVSolver;  keyword arguments ) :: CLVSolver  Solve pre-initialized problem.  source  #  DiffEqBase.solve     Function .  solve(prob::LEProblem;  keyword arguments ) :: LESolution\nsolve(prob::CLVProblem;  keyword arguments ) :: CLVSolution  Equivalent to:  solver = init(prob;  keyword arguments except progress )\nsolve!(solver; progress=progress)\nsolver.sol  source  #  LyapunovExponents.PhaseTangentDynamics     Type .  Auto-generated dynamics for solving phase and tangent dynamics together.  source", 
            "title": "Low-level API"
        }, 
        {
            "location": "/api/#api-for-clv-solver", 
            "text": "#  LyapunovExponents.CovariantVectors.CLVProblem     Type .  CLVProblem(phase_prob, t_clv;  keyword arguments )\nCLVProblem(le_prob::LEProblem;  keyword arguments )  Covariant Lyapunov vector (CLV) problem.  This is a struct that holds the dynamical system definition ( phase_prob  and  tangent_dynamics ) and the configuration parameters for the algorithm ( t_clv , etc.).  The CLVs are calculated using the 'dynamical' algorithm proposed by Ginelli et al. (2007, 2013).  Arguments   t_clv::Real : Time spam for which CLV are sampled. It is  0.8 * le_prob.t_attr  when constructed from  LEProblem .  t_forward_tran::Real ,  t_backward_tran::Real : Forward and backward transient dynamics.  They are  0.1 * le_prob.t_attr  when constructed from  LEProblem .  See  LEProblem  for  phase_prob ,  t_renorm ,  tangent_dynamics  and  Q0 .   Examples (in the online documentation)   Ginelli et al. (2007), Figure 1a  Covariant Lyapunov vectors on the Lorenz attractor   See:  https://tkf.github.io/LyapunovExponents.jl/latest/gallery/  Reference   Ginelli, F., Poggi, P., Turchi, A., Chat\u00e9, H., Livi, R.,   Politi, A. (2007).  Characterizing Dynamics with Covariant Lyapunov Vectors.  Physical Review Letters, 99(13), 1\u20134.  http://doi.org/10.1103/PhysRevLett.99.130601  Ginelli, F., Chat\u00e9, H., Livi, R.,   Politi, A. (2013).  Covariant Lyapunov vectors.  Journal of Physics A: Mathematical and Theoretical, 46(25), 254005.  http://doi.org/10.1088/1751-8113/46/25/254005   source  #  LyapunovExponents.CovariantVectors.CLVSolver     Type .  CLVSolver(prob::CLVProblem;  keyword arguments )\nCLVSolver(prob::LEProblem;  keyword arguments )  The preferred and equivalent method to get a solver for a  CLVProblem  is  init(prob::CLVProblem) .  Note that  CLVSolver(prob::LEProblem)  is equivalent to  init(CLVProblem(prob)) .  Arguments   record::Vector{Symbol} : Variables to be saved.  A subset of  [:G, :C, :D, :x] .   source  #  LyapunovExponents.CovariantVectors.CLV     Module .  Convenience methods for accessing CLV matrices.  Methods  CLV.C ,  CLV.R  and  CLV.G  are the accessor to the matrices $C$, $R$ and $G$ in   \nG_{n+k} C_{n+k} D_{k,n} = M_{k,n} G_n C_n = G_{n+k} R_{k,n} C_n   (Eq. 32, Ginelli et al., 2013).  source  #  LyapunovExponents.CovariantVectors.CLV.M     Function .  $M_n$ (the cocycle)  source  #  LyapunovExponents.CovariantVectors.CLV.G     Function .  $G_n$ ( Q  from the QR decomposition of $M_{k,n-k} G_{n-k}$)  source  #  LyapunovExponents.CovariantVectors.CLV.R     Function .  $R_n$ ( R  from the QR decomposition of $M_{k,n-k} G_{n-k}$)  source  #  LyapunovExponents.CovariantVectors.CLV.R_prev     Function .  $R_{n-k}$  source  #  LyapunovExponents.CovariantVectors.CLV.C     Function .  $C_n$  source  #  LyapunovExponents.CovariantVectors.CLV.D     Function .  $D_n$  source  #  LyapunovExponents.phase_state     Function .  phase_state(stage) :: Vector  Get current phase-space state stored in  stage .  source  #  LyapunovExponents.CovariantVectors.forward_dynamics!     Function .  forward_dynamics!(solver::CLVSolver) :: ForwardDynamics  Solve the CLV problem up to the forward dynamics stage and return an iterator to step through the forward dynamics. See also:  backward_dynamics! ,  goto! .  source  #  LyapunovExponents.CovariantVectors.backward_dynamics!     Function .  backward_dynamics!(solver::CLVSolver) :: BackwardDynamics  Solve the CLV problem up to the (final) backward dynamics stage and return an iterator to step through the backward dynamics. See also  forward_dynamics! ,  goto! .  Note that finishing iteration of the returned iterator does not finalize all the solver stages (namely, recording to  solver.sol , if non-default  backward_dynamics  is used).  In this case,  solve!(solver)  has to be called after the iteration.  Example  angles = [acos(abs(dot(C[:, 1], C[:, 2]))) * 2 / \u03c0 for C\n          in backward_dynamics!(solver)]  source  #  LyapunovExponents.CovariantVectors.indexed_forward_dynamics!     Function .  indexed_forward_dynamics!(solver::CLVSolver)\nindexed_forward_dynamics!(stage::ForwardDynamics)  Just a short-hand for  enumerate(forward_dynamics!(solver)) . It's for symmetry with  indexed_backward_dynamics! .  source  #  LyapunovExponents.CovariantVectors.indexed_backward_dynamics!     Function .  indexed_backward_dynamics!(solver::CLVSolver)\nindexed_backward_dynamics!(stage::BackwardDynamics)  It is equivalent to  zip(some_counter, backward_dynamics!(solver))  where  some_counter  is an iterator over integers such that the same indices returned by  indexed_forward_dynamics!  indicate that those events are at the same time point of the backward and forward passes.  This is useful when combining matrices  CLV.G  and  CLV.C  to obtain the CLV in the (original) tangent space.  For such example, see:  Covariant Lyapunov vectors on the Lorenz attractor  in the online manual.  Note that  indexed_backward_dynamics!(solver::CLVSolver)  is equivalent to  backward = backward_dynamics!(solver)\nindexed_backward_dynamics!(backward)  Separately calling  backward_dynamics!  is useful when the quantities other than  CLV.G  (e.g.,  CLV.R ) are required.  See also  indexed_forward_dynamics! .  source", 
            "title": "API for CLV solver"
        }, 
        {
            "location": "/api/#low-level-api-for-clv-solver", 
            "text": "#  LyapunovExponents.Stages.goto!     Function .  goto!(solver::StagedSolver, stage_type::Type{T}) :: T  Advance the  solver  up to the stage of type  stage_type  and return it.  source", 
            "title": "Low-level API for CLV solver"
        }, 
        {
            "location": "/examples/", 
            "text": "Example dynamical systems\n\n\n#\n\n\nLyapunovExponents.Examples.ExampleBase.LEDemo\n \n \nType\n.\n\n\nLEDemo(example::LEExample; \nkeyword arguments\n)\n\n\n\n\nHere is an example code for constructing an example dynamical system, calculate its LEs and plot them:\n\n\nusing LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.lorenz_63())\nplot(demo)\n\n\n\n\nCreate a \nLEDemo\n holding an \nexample\n and an appropriate \nLEProblem\n created from the \nexample\n.\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.Examples.ExampleBase.LEExample\n \n \nType\n.\n\n\nA type to hold an example dynamical system and its known Lyapunov exponents.\n\n\nsource\n\n\n\n\nDiscrete systems\n\n\n#\n\n\nLyapunovExponents.Examples.HenonMap.henon_map\n \n \nFunction\n.\n\n\nReturn a \nLEDemo\n for the H\u00e9non map.\n\n\n\n\nM. H\u00e9non, Commun. Math. Phys. Phys. 50, 69-77 (1976)\n\n\nhttp://sprott.physics.wisc.edu/chaos/comchaos.htm\n\n\nhttps://en.wikipedia.org/wiki/H%C3%A9non_map\n\n\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.Examples.LoziMap.lozi_map\n \n \nFunction\n.\n\n\nReturn a \nLEDemo\n for the Lozi map.\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.Examples.StandardMap.standard_map\n \n \nFunction\n.\n\n\nReturn a \nLEDemo\n for the Chirikov standard map.\n\n\n\n\nB. V. Chirikov, Physics Reports 52, 263-379 (1979)\n\n\nhttp://sprott.physics.wisc.edu/chaos/comchaos.htm\n\n\nhttps://en.wikipedia.org/wiki/Standard_map\n\n\nhttp://www.scholarpedia.org/article/Chirikov_standard_map\n\n\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.Examples.BakersMap.bakers_map\n \n \nFunction\n.\n\n\nBaker's map\n\n\n\n\nhttps://en.wikipedia.org/wiki/Baker%27s_map\n\n\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.Examples.ArnoldCatMap.arnold_cat_map\n \n \nFunction\n.\n\n\nReturn a \nLEDemo\n for the Arnold's cat map\n\n\n\n\nhttps://en.wikipedia.org/wiki/Arnold%27s_cat_map\n\n\n\n\nsource\n\n\n\n\nContinuous systems\n\n\n#\n\n\nLyapunovExponents.Examples.Lorenz63.lorenz_63\n \n \nFunction\n.\n\n\nReturn a \nLEDemo\n for the Lorenz system.\n\n\n\n\nhttps://en.wikipedia.org/wiki/Lorenz_system\n\n\nhttp://sprott.physics.wisc.edu/chaos/comchaos.htm\n\n\nE. N. Lorenz, J. Atmos. Sci. 20, 130-141 (1963)\n\n\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.Examples.LinzSprott99.linz_sprott_99\n \n \nFunction\n.\n\n\nReturn a \nLEDemo\n for the simplest piecewise linear dissipative chaotic flow.\n\n\n\n\nhttp://sprott.physics.wisc.edu/chaos/comchaos.htm\n\n\nS. J. Linz and J. C. Sprott, Phys. Lett. A 259, 240-245 (1999)\n\n\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.Examples.VanDerPol.van_der_pol\n \n \nFunction\n.\n\n\nReturn a \nLEDemo\n for the van der Pol oscillator with periodic forcing.\n\n\n.known_exponents\n are extracted from Figure 6 of Geist, Parlitz \n Lauterborn (1990).\n\n\n\n\nhttp://scholarpedia.org/article/Van_der_Pol_oscillator\n\n\nhttps://en.wikipedia.org/wiki/Van_der_Pol_oscillator\n\n\nvan der Pol and van der Mark. \u201cFrequency Demultiplication.\u201d Nature 120, no. 3019 (September 1927): 363. \nhttps://doi.org/10.1038/120363a0\n.\n\n\nParlitz, Ulrich, and Werner Lauterborn. \u201cPeriod-Doubling Cascades and Devil\u2019s Staircases of the Driven van Der Pol Oscillator.\u201d Physical Review A 36, no. 3 (August 1, 1987): 1428\u201334. \nhttps://doi.org/10.1103/PhysRevA.36.1428\n. (Figure 10a)\n\n\nGeist, K., Parlitz, U., \n Lauterborn, W. (1990). Comparison of Different Methods for Computing Lyapunov Exponents. Progress of Theoretical Physics, 83, 875\u2013893. \nhttps://doi.org/10.1143/PTP.83.875\n. (Figure 6)\n\n\n\n\nsource\n\n\n#\n\n\nLyapunovExponents.Examples.RNN.beer_95\n \n \nFunction\n.\n\n\nReturn a \nLEDemo\n for a low-dimensional chaotic continuous-time recurrent neural networks by Beer (1995).\n\n\n\n\nBeer, R. D. (1995). On the dynamics of small continuous-time recurrent neural networks. Adapt. Behav., 3(4), 469\u2013509. \nhttps://doi.org/10.1177/105971239500300405\n. (Figure 9D)\n\n\n\n\nsource", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#example-dynamical-systems", 
            "text": "#  LyapunovExponents.Examples.ExampleBase.LEDemo     Type .  LEDemo(example::LEExample;  keyword arguments )  Here is an example code for constructing an example dynamical system, calculate its LEs and plot them:  using LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.lorenz_63())\nplot(demo)  Create a  LEDemo  holding an  example  and an appropriate  LEProblem  created from the  example .  source  #  LyapunovExponents.Examples.ExampleBase.LEExample     Type .  A type to hold an example dynamical system and its known Lyapunov exponents.  source", 
            "title": "Example dynamical systems"
        }, 
        {
            "location": "/examples/#discrete-systems", 
            "text": "#  LyapunovExponents.Examples.HenonMap.henon_map     Function .  Return a  LEDemo  for the H\u00e9non map.   M. H\u00e9non, Commun. Math. Phys. Phys. 50, 69-77 (1976)  http://sprott.physics.wisc.edu/chaos/comchaos.htm  https://en.wikipedia.org/wiki/H%C3%A9non_map   source  #  LyapunovExponents.Examples.LoziMap.lozi_map     Function .  Return a  LEDemo  for the Lozi map.  source  #  LyapunovExponents.Examples.StandardMap.standard_map     Function .  Return a  LEDemo  for the Chirikov standard map.   B. V. Chirikov, Physics Reports 52, 263-379 (1979)  http://sprott.physics.wisc.edu/chaos/comchaos.htm  https://en.wikipedia.org/wiki/Standard_map  http://www.scholarpedia.org/article/Chirikov_standard_map   source  #  LyapunovExponents.Examples.BakersMap.bakers_map     Function .  Baker's map   https://en.wikipedia.org/wiki/Baker%27s_map   source  #  LyapunovExponents.Examples.ArnoldCatMap.arnold_cat_map     Function .  Return a  LEDemo  for the Arnold's cat map   https://en.wikipedia.org/wiki/Arnold%27s_cat_map   source", 
            "title": "Discrete systems"
        }, 
        {
            "location": "/examples/#continuous-systems", 
            "text": "#  LyapunovExponents.Examples.Lorenz63.lorenz_63     Function .  Return a  LEDemo  for the Lorenz system.   https://en.wikipedia.org/wiki/Lorenz_system  http://sprott.physics.wisc.edu/chaos/comchaos.htm  E. N. Lorenz, J. Atmos. Sci. 20, 130-141 (1963)   source  #  LyapunovExponents.Examples.LinzSprott99.linz_sprott_99     Function .  Return a  LEDemo  for the simplest piecewise linear dissipative chaotic flow.   http://sprott.physics.wisc.edu/chaos/comchaos.htm  S. J. Linz and J. C. Sprott, Phys. Lett. A 259, 240-245 (1999)   source  #  LyapunovExponents.Examples.VanDerPol.van_der_pol     Function .  Return a  LEDemo  for the van der Pol oscillator with periodic forcing.  .known_exponents  are extracted from Figure 6 of Geist, Parlitz   Lauterborn (1990).   http://scholarpedia.org/article/Van_der_Pol_oscillator  https://en.wikipedia.org/wiki/Van_der_Pol_oscillator  van der Pol and van der Mark. \u201cFrequency Demultiplication.\u201d Nature 120, no. 3019 (September 1927): 363.  https://doi.org/10.1038/120363a0 .  Parlitz, Ulrich, and Werner Lauterborn. \u201cPeriod-Doubling Cascades and Devil\u2019s Staircases of the Driven van Der Pol Oscillator.\u201d Physical Review A 36, no. 3 (August 1, 1987): 1428\u201334.  https://doi.org/10.1103/PhysRevA.36.1428 . (Figure 10a)  Geist, K., Parlitz, U.,   Lauterborn, W. (1990). Comparison of Different Methods for Computing Lyapunov Exponents. Progress of Theoretical Physics, 83, 875\u2013893.  https://doi.org/10.1143/PTP.83.875 . (Figure 6)   source  #  LyapunovExponents.Examples.RNN.beer_95     Function .  Return a  LEDemo  for a low-dimensional chaotic continuous-time recurrent neural networks by Beer (1995).   Beer, R. D. (1995). On the dynamics of small continuous-time recurrent neural networks. Adapt. Behav., 3(4), 469\u2013509.  https://doi.org/10.1177/105971239500300405 . (Figure 9D)   source", 
            "title": "Continuous systems"
        }, 
        {
            "location": "/gallery/", 
            "text": "Gallery\n\n\n\n\nGinelli et al. (2007), Figure 1a\n\n\nCovariant Lyapunov vectors on the Lorenz attractor\n\n\nExample: \narnold_cat_map\n\n\nExample: \nbakers_map\n\n\nExample: \nbeer_95\n\n\nExample: \nhenon_map\n\n\nExample: \nlinz_sprott_99\n\n\nExample: \nlorenz_63\n\n\nExample: \nlozi_map\n\n\nExample: \nstandard_map\n\n\nExample: \nvan_der_pol", 
            "title": "Home"
        }, 
        {
            "location": "/gallery/#gallery", 
            "text": "Ginelli et al. (2007), Figure 1a  Covariant Lyapunov vectors on the Lorenz attractor  Example:  arnold_cat_map  Example:  bakers_map  Example:  beer_95  Example:  henon_map  Example:  linz_sprott_99  Example:  lorenz_63  Example:  lozi_map  Example:  standard_map  Example:  van_der_pol", 
            "title": "Gallery"
        }, 
        {
            "location": "/gallery/Ginelli_2007_Figure_1a/", 
            "text": "Ginelli et al. (2007), Figure 1a\n\n\n\n\nThis is an attempt to reproduce Figure 1a of \nGinelli et al. (2007)\n. The following code sets up two problems \nCLVProblem\n to compute the covariant Lyapunov vectors (CLVs) of the two-dimensional maps, the H\u00e9non map (\nLyapunovExponents.henon_map\n) and the Lozi map (\nLyapunovExponents.lozi_map\n).\n\n\nThe probability density function of the angles between the two CLVs are plotted.  See \nGinelli et al. (2007)\n for how the shape of this probability density function is related to hyperbolicity.\n\n\nusing LyapunovExponents\n\nfunction get_angles(solver)\n    return [acos(abs(dot(C[:, 1], C[:, 2]))) * 2 / \u03c0 for C\n            in backward_dynamics!(solver; progress=1)]\nend\n\nhenon_demo = LyapunovExponents.henon_map(t_attr=1000000)\nhenon_demo.prob :: LEProblem\nhenon_prob = CLVProblem(henon_demo.prob)  # convert it to CLVProblem\nhenon_angles = @time get_angles(init(henon_prob))\n\nlozi_prob = CLVProblem(LyapunovExponents.lozi_map(t_attr=1000000).prob)\nlozi_angles = @time get_angles(init(lozi_prob))\n\nusing Plots\nplt = plot(xlabel=\nAngle [pi/2 rad]\n, ylabel=\nDensity\n, legend=:topleft)\nstephist!(plt, henon_angles,\n          bins=1000, normalize=true, linecolor=1, label=\nHenon\n)\nstephist!(twinx(plt), lozi_angles,\n          bins=1000, normalize=true, linecolor=2, label=\nLozi\n)\nplt", 
            "title": "Ginelli 2007 Figure 1a"
        }, 
        {
            "location": "/gallery/Ginelli_2007_Figure_1a/#ginelli-et-al-2007-figure-1a", 
            "text": "This is an attempt to reproduce Figure 1a of  Ginelli et al. (2007) . The following code sets up two problems  CLVProblem  to compute the covariant Lyapunov vectors (CLVs) of the two-dimensional maps, the H\u00e9non map ( LyapunovExponents.henon_map ) and the Lozi map ( LyapunovExponents.lozi_map ).  The probability density function of the angles between the two CLVs are plotted.  See  Ginelli et al. (2007)  for how the shape of this probability density function is related to hyperbolicity.  using LyapunovExponents\n\nfunction get_angles(solver)\n    return [acos(abs(dot(C[:, 1], C[:, 2]))) * 2 / \u03c0 for C\n            in backward_dynamics!(solver; progress=1)]\nend\n\nhenon_demo = LyapunovExponents.henon_map(t_attr=1000000)\nhenon_demo.prob :: LEProblem\nhenon_prob = CLVProblem(henon_demo.prob)  # convert it to CLVProblem\nhenon_angles = @time get_angles(init(henon_prob))\n\nlozi_prob = CLVProblem(LyapunovExponents.lozi_map(t_attr=1000000).prob)\nlozi_angles = @time get_angles(init(lozi_prob))\n\nusing Plots\nplt = plot(xlabel= Angle [pi/2 rad] , ylabel= Density , legend=:topleft)\nstephist!(plt, henon_angles,\n          bins=1000, normalize=true, linecolor=1, label= Henon )\nstephist!(twinx(plt), lozi_angles,\n          bins=1000, normalize=true, linecolor=2, label= Lozi )\nplt", 
            "title": "Ginelli et al. (2007), Figure 1a"
        }, 
        {
            "location": "/gallery/Lorenz_CLV/", 
            "text": "Covariant Lyapunov vectors on the Lorenz attractor\n\n\n\n\nThis is a demonstration for solving CLV problem \nCLVProblem\n and receiving the results via the iterator-based APIs \nindexed_forward_dynamics!\n, \nindexed_backward_dynamics!\n, \nCLV\n, etc.\n\n\nusing LyapunovExponents\n\nnum_rec = 20\nsampling_interval = 5\nt_renorm = 1\nt_clv = t_renorm * num_rec * sampling_interval\nprob = CLVProblem(LyapunovExponents.lorenz_63().prob,\n                  t_renorm = t_renorm,\n                  t_forward_tran = 4000,\n                  t_backward_tran = 4000,\n                  t_clv = t_clv)\nsolver = init(prob)\n\nx_history = [Vector{Float64}(3) for _ in 1:num_rec]\nG_history = [Matrix{Float64}(3, 3) for _ in 1:num_rec]\nC_history = [Matrix{Float64}(3, 3) for _ in 1:num_rec]\n\nforward = @time forward_dynamics!(solver; progress=1)\n@time for (i, G) in indexed_forward_dynamics!(forward)\n    k, r = divrem(i, sampling_interval)\n    j = k + 1\n    if r == 1 \n j \n= num_rec\n        x_history[j] .= phase_state(forward)\n        G_history[j] .= G\n    end\nend\n\n@time for (i, C) in @time indexed_backward_dynamics!(solver; progress=1)\n    k, r = divrem(i, sampling_interval)\n    j = k + 1\n    if r == 1\n        C_history[j] .= C\n    end\nend\n\nCLV_history = [G * C for (G, C) in zip(G_history, C_history)]\n\nusing DifferentialEquations\nsol = solve(ODEProblem(\n    prob.phase_prob.f,\n    x_history[1],\n    (0.0, t_clv * 3),\n    prob.phase_prob.p\n))\n\nusing Plots\nplt = plot(sol, vars=(2, 3), linewidth=0.5, linealpha=0.5, label=\n)\nvec_scale = 3\nfor (n, (x, V)) in enumerate(zip(x_history, CLV_history))\n    for i in 1:3\n        plot!(plt,\n              [x[2], x[2] + vec_scale * V[2, i]],\n              [x[3], x[3] + vec_scale * V[3, i]],\n              color = i + 1,\n              arrow = 0.4,\n              label = (n == 1 ? \nCLV$i\n : \n))\n    end\nend\nplt", 
            "title": "Lorenz CLV"
        }, 
        {
            "location": "/gallery/Lorenz_CLV/#covariant-lyapunov-vectors-on-the-lorenz-attractor", 
            "text": "This is a demonstration for solving CLV problem  CLVProblem  and receiving the results via the iterator-based APIs  indexed_forward_dynamics! ,  indexed_backward_dynamics! ,  CLV , etc.  using LyapunovExponents\n\nnum_rec = 20\nsampling_interval = 5\nt_renorm = 1\nt_clv = t_renorm * num_rec * sampling_interval\nprob = CLVProblem(LyapunovExponents.lorenz_63().prob,\n                  t_renorm = t_renorm,\n                  t_forward_tran = 4000,\n                  t_backward_tran = 4000,\n                  t_clv = t_clv)\nsolver = init(prob)\n\nx_history = [Vector{Float64}(3) for _ in 1:num_rec]\nG_history = [Matrix{Float64}(3, 3) for _ in 1:num_rec]\nC_history = [Matrix{Float64}(3, 3) for _ in 1:num_rec]\n\nforward = @time forward_dynamics!(solver; progress=1)\n@time for (i, G) in indexed_forward_dynamics!(forward)\n    k, r = divrem(i, sampling_interval)\n    j = k + 1\n    if r == 1   j  = num_rec\n        x_history[j] .= phase_state(forward)\n        G_history[j] .= G\n    end\nend\n\n@time for (i, C) in @time indexed_backward_dynamics!(solver; progress=1)\n    k, r = divrem(i, sampling_interval)\n    j = k + 1\n    if r == 1\n        C_history[j] .= C\n    end\nend\n\nCLV_history = [G * C for (G, C) in zip(G_history, C_history)]\n\nusing DifferentialEquations\nsol = solve(ODEProblem(\n    prob.phase_prob.f,\n    x_history[1],\n    (0.0, t_clv * 3),\n    prob.phase_prob.p\n))\n\nusing Plots\nplt = plot(sol, vars=(2, 3), linewidth=0.5, linealpha=0.5, label= )\nvec_scale = 3\nfor (n, (x, V)) in enumerate(zip(x_history, CLV_history))\n    for i in 1:3\n        plot!(plt,\n              [x[2], x[2] + vec_scale * V[2, i]],\n              [x[3], x[3] + vec_scale * V[3, i]],\n              color = i + 1,\n              arrow = 0.4,\n              label = (n == 1 ?  CLV$i  :  ))\n    end\nend\nplt", 
            "title": "Covariant Lyapunov vectors on the Lorenz attractor"
        }, 
        {
            "location": "/gallery/examples/arnold_cat_map/", 
            "text": "Example: \narnold_cat_map\n\n\n\n\nUse \nLyapunovExponents.arnold_cat_map\n to generate a \nLyapunovExponents.LEDemo\n (which wraps \nLEProblem\n) and solve it.\n\n\nusing LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.arnold_cat_map(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Arnold cat map"
        }, 
        {
            "location": "/gallery/examples/arnold_cat_map/#example-arnold_cat_map", 
            "text": "Use  LyapunovExponents.arnold_cat_map  to generate a  LyapunovExponents.LEDemo  (which wraps  LEProblem ) and solve it.  using LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.arnold_cat_map(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Example: arnold_cat_map"
        }, 
        {
            "location": "/gallery/examples/bakers_map/", 
            "text": "Example: \nbakers_map\n\n\n\n\nUse \nLyapunovExponents.bakers_map\n to generate a \nLyapunovExponents.LEDemo\n (which wraps \nLEProblem\n) and solve it.\n\n\nusing LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.bakers_map(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Bakers map"
        }, 
        {
            "location": "/gallery/examples/bakers_map/#example-bakers_map", 
            "text": "Use  LyapunovExponents.bakers_map  to generate a  LyapunovExponents.LEDemo  (which wraps  LEProblem ) and solve it.  using LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.bakers_map(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Example: bakers_map"
        }, 
        {
            "location": "/gallery/examples/beer_95/", 
            "text": "Example: \nbeer_95\n\n\n\n\nUse \nLyapunovExponents.beer_95\n to generate a \nLyapunovExponents.LEDemo\n (which wraps \nLEProblem\n) and solve it.\n\n\nusing LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.beer_95(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Beer 95"
        }, 
        {
            "location": "/gallery/examples/beer_95/#example-beer_95", 
            "text": "Use  LyapunovExponents.beer_95  to generate a  LyapunovExponents.LEDemo  (which wraps  LEProblem ) and solve it.  using LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.beer_95(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Example: beer_95"
        }, 
        {
            "location": "/gallery/examples/henon_map/", 
            "text": "Example: \nhenon_map\n\n\n\n\nUse \nLyapunovExponents.henon_map\n to generate a \nLyapunovExponents.LEDemo\n (which wraps \nLEProblem\n) and solve it.\n\n\nusing LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.henon_map(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Henon map"
        }, 
        {
            "location": "/gallery/examples/henon_map/#example-henon_map", 
            "text": "Use  LyapunovExponents.henon_map  to generate a  LyapunovExponents.LEDemo  (which wraps  LEProblem ) and solve it.  using LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.henon_map(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Example: henon_map"
        }, 
        {
            "location": "/gallery/examples/linz_sprott_99/", 
            "text": "Example: \nlinz_sprott_99\n\n\n\n\nUse \nLyapunovExponents.linz_sprott_99\n to generate a \nLyapunovExponents.LEDemo\n (which wraps \nLEProblem\n) and solve it.\n\n\nusing LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.linz_sprott_99(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Linz sprott 99"
        }, 
        {
            "location": "/gallery/examples/linz_sprott_99/#example-linz_sprott_99", 
            "text": "Use  LyapunovExponents.linz_sprott_99  to generate a  LyapunovExponents.LEDemo  (which wraps  LEProblem ) and solve it.  using LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.linz_sprott_99(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Example: linz_sprott_99"
        }, 
        {
            "location": "/gallery/examples/lorenz_63/", 
            "text": "Example: \nlorenz_63\n\n\n\n\nUse \nLyapunovExponents.lorenz_63\n to generate a \nLyapunovExponents.LEDemo\n (which wraps \nLEProblem\n) and solve it.\n\n\nusing LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.lorenz_63(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Lorenz 63"
        }, 
        {
            "location": "/gallery/examples/lorenz_63/#example-lorenz_63", 
            "text": "Use  LyapunovExponents.lorenz_63  to generate a  LyapunovExponents.LEDemo  (which wraps  LEProblem ) and solve it.  using LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.lorenz_63(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Example: lorenz_63"
        }, 
        {
            "location": "/gallery/examples/lozi_map/", 
            "text": "Example: \nlozi_map\n\n\n\n\nUse \nLyapunovExponents.lozi_map\n to generate a \nLyapunovExponents.LEDemo\n (which wraps \nLEProblem\n) and solve it.\n\n\nusing LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.lozi_map(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Lozi map"
        }, 
        {
            "location": "/gallery/examples/lozi_map/#example-lozi_map", 
            "text": "Use  LyapunovExponents.lozi_map  to generate a  LyapunovExponents.LEDemo  (which wraps  LEProblem ) and solve it.  using LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.lozi_map(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Example: lozi_map"
        }, 
        {
            "location": "/gallery/examples/standard_map/", 
            "text": "Example: \nstandard_map\n\n\n\n\nUse \nLyapunovExponents.standard_map\n to generate a \nLyapunovExponents.LEDemo\n (which wraps \nLEProblem\n) and solve it.\n\n\nusing LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.standard_map(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Standard map"
        }, 
        {
            "location": "/gallery/examples/standard_map/#example-standard_map", 
            "text": "Use  LyapunovExponents.standard_map  to generate a  LyapunovExponents.LEDemo  (which wraps  LEProblem ) and solve it.  using LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.standard_map(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Example: standard_map"
        }, 
        {
            "location": "/gallery/examples/van_der_pol/", 
            "text": "Example: \nvan_der_pol\n\n\n\n\nUse \nLyapunovExponents.van_der_pol\n to generate a \nLyapunovExponents.LEDemo\n (which wraps \nLEProblem\n) and solve it.\n\n\nusing LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.van_der_pol(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Van der pol"
        }, 
        {
            "location": "/gallery/examples/van_der_pol/#example-van_der_pol", 
            "text": "Use  LyapunovExponents.van_der_pol  to generate a  LyapunovExponents.LEDemo  (which wraps  LEProblem ) and solve it.  using LyapunovExponents\nusing Plots\ndemo = solve!(LyapunovExponents.van_der_pol(); progress=1)\nreport(demo)\nplt = plot(demo)", 
            "title": "Example: van_der_pol"
        }
    ]
}